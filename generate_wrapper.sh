#!/bin/bash

if [ "$#" -ne 3 ]; then
    echo "Usage: $0 <tool_name> <input_type> <output_type>"
    exit 1
fi

tool_name=$1       # e.g., 'fasta_reverse'
input_type=$2      # 'file' or 'stdin'
output_type=$3     # 'file' or 'stdout'

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# Ensure public/wasm directory exists
mkdir -p "$SCRIPT_DIR/public/wasm"

wrapper_file="$SCRIPT_DIR/public/wasm/${tool_name}_wrapper.js"

cat > "$wrapper_file" <<EOL
/**
 * Wrapper function for the ${tool_name} module.
 * Automatically generated by generate_wrapper.sh
 */

(function() {
  window.run_${tool_name} = async function(inputData, args = []) {
    try {
      const moduleInstance = await window.createModule_${tool_name}({
        noInitialRun: true,
      });
EOL

if [ "$input_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL

      // Write input data to the virtual filesystem
      moduleInstance.FS.writeFile('/input.txt', inputData);
      const inputFile = '/input.txt';
EOL
fi

if [ "$output_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL

      const outputFile = '/output.txt';
EOL
fi

if [ "$input_type" = "stdin" ] || [ "$output_type" = "stdout" ]; then
  cat >> "$wrapper_file" <<'EOL'

      // Initialize custom stdin and stdout
EOL

  if [ "$input_type" = "stdin" ]; then
    cat >> "$wrapper_file" <<'EOL'
      const inputDataBuffer = (new TextEncoder()).encode(inputData);
      let inputIndex = 0;

      const customStdin = function() {
        if (inputIndex >= inputDataBuffer.length) {
          return null; // EOF
        } else {
          return inputDataBuffer[inputIndex++];
        }
      };
EOL
  fi

  if [ "$output_type" = "stdout" ]; then
    cat >> "$wrapper_file" <<'EOL'
      let outputText = '';
      const customStdout = function(c) {
        outputText += String.fromCharCode(c);
      };
EOL
  fi

  cat >> "$wrapper_file" <<EOL

      moduleInstance.FS.init(
        '${input_type}' === 'stdin' ? customStdin : null,
        '${output_type}' === 'stdout' ? customStdout : null,
        null
      );
EOL
fi

cat >> "$wrapper_file" <<EOL

      const argv = ['${tool_name}'];
EOL

if [ "$input_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL
      argv.push(inputFile);
EOL
fi

if [ "$output_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL
      argv.push(outputFile);
EOL
fi

cat >> "$wrapper_file" <<EOL

      argv.push(...args);

      moduleInstance.callMain(argv);

EOL

if [ "$output_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL
      // Read output from the virtual filesystem
      const outputText = moduleInstance.FS.readFile(outputFile, { encoding: 'utf8' });

      // Clean up output file
      moduleInstance.FS.unlink(outputFile);
EOL
fi

if [ "$input_type" = "file" ]; then
  cat >> "$wrapper_file" <<EOL

      // Clean up input file
      moduleInstance.FS.unlink(inputFile);
EOL
fi

cat >> "$wrapper_file" <<EOL

      return outputText${output_type} === 'stdout' ? '.trim()' : '';
    } catch (err) {
      console.error('Error in run_${tool_name}:', err);
      throw err;
    }
  };

  window.createModule_${tool_name} = function(moduleOverrides = {}) {
    return new Promise((resolve, reject) => {
      var script = document.createElement('script');
      script.src = '/wasm/${tool_name}.js';
      script.onload = () => {
        var moduleFactory = window['${tool_name}'];
        if (typeof moduleFactory !== 'function') {
          return reject(new Error('Module factory function not found.'));
        }
        moduleFactory({
          ...moduleOverrides,
          locateFile: (path, prefix) => {
            if (path.endsWith('.wasm')) {
              return '/wasm/' + path;
            }
            return prefix + path;
          }
        }).then(resolve).catch(reject);
      };
      script.onerror = reject;
      document.head.appendChild(script);
    });
  };
})();
EOL

echo "Generated wrapper for ${tool_name} at ${wrapper_file}"